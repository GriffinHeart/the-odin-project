<!DOCTYPE HTML>
<html>
<head>
</head>
<body>
    
<p>Please input an integer greater than one to factorize:</p>
<input id="numb" type="number">
<button type="button" onclick="myFactorization()">Submit</button>
<p id="demo"></p>
    
<script>
function myFactorization(){
// This function generates the prime factorization for a given integer greater than or equal to 2

N = document.getElementById("numb").value; // Get the value from the text box

    // Do some error checking to make sure we actually have an integer > 2
    if (isNaN(N) || N < 2 || Math.floor(N) != N) {
        text = "Input not valid";
        document.getElementById("demo").innerHTML = text;
        return 0;
        }
    
    
var theNumber = Math.ceil(Math.sqrt(N)); // The largest prime factor can only be up to sqrt(N)

// Instead of testing [2,3,4,...,theNumber] for primality one-by-one, we will generate all the primes in advance.
// We will generate primes using the "Sieve of Eratosthenes" Method
// See: http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes

// We need to generate prime numbers up to "theNumber", so our sieve will require the use of numbers
// up to sqrt(theNumber)
var sieveMax = Math.ceil(Math.sqrt(theNumber));

var primes = []; // This variable holds all the primes up to "theNumber"
primes[0]  =  2; // The first prime is 2

var primeTest = [];  // This will be the array used in the Sieve method [1,2,3,4,...,theNumber]
primeTest.length = theNumber; 
primeTest[0] = 0; // 1 is not a prime so go ahead and mark it as zero
primeTest[1] = 2;

// All the even numbers are not prime so go ahead and put in zero in all the 2s places
for(var x = 3; x<primeTest.length; x=x+2){
primeTest[x] = 0;
}

// For the rest of the entries, fill in the odd numbers
for(var x = 2; x<primeTest.length; x=x+2){
primeTest[x] = x+1;
} // At this point primeTest looks like [0,2,3,0,5,0,7,0,9,0,11,0,13,0,15,...,theNumber]

// Implement the Sieve algorithm, zeroing out each multiple of 3,
// then each multiple of 5, each multiple of 7, etc.
for(var skip = 3; skip<=sieveMax; skip++){ // Start at 3 and work up to sieveMax 
   if (primeTest[skip-1] != 0){            // If the number is already zeroed out, then we don't need to sieve it
       for(var x = 2*skip-1; x<=theNumber; x = x+skip){
            primeTest[x] = 0;              // Zero out all the multiples of "skip"
       }
    }
}

// At this point, the only nonzero entries of primeTest are the prime numbers,
// so gather them and put them all in the "primes" variable
for(var x = 2; x<primeTest.length; x++){
    if (primeTest[x] != 0){
        primes.push(primeTest[x]);
    }
}


var factors = []; // This array will hold the factors of N

var thisPrime;
for(var k=0; k<primes.length; k++){
     //while(N % primes[k] === 0){     // The "%" operator works, but can't handle extremely large numbers
      thisPrime = primes[k];
      while(largeMod(N,thisPrime) === 0){   //call largeMod to handle modulo for large numbers
            factors.push(thisPrime);        // If it is divisible, add it to the factors list...
            N = N / thisPrime;              // ... and then divide it out of N.
        }
}

// If there is anything left, then it must the last prime factor
if (N > 1){
    factors.push(N);
}

document.getElementById("demo").innerHTML = factors; // Write out the output
//window.alert(Math.max.apply(null, factors)); // Largest number in the array

}




function largeMod(N,m){
// This function is equivalent to N % m, however it handles large numbers
// correctly. Essentially, we keep subtracting off of N  a large multiple
// of m, until N becomes small enough that we can call "%" on it.

    var LOG2 = Math.log(2);
    var orderm=Math.floor(Math.log(m)/LOG2); // "size" of n in base 2
    var orderN;                              // "size" of M in base 2
    var toSubtract;
    var Nlimit = 1000000000; // Keep going until N is smaller than this
        
    while (N > Nlimit){
        orderN=Math.floor(Math.log(N)/LOG2);
        toSubtract = m*(Math.pow(2,orderN-orderm)); // Generate a multiple of m to subtract
        if (toSubtract > N){    // If the multiple is too big, cut it down by 2
            toSubtract = toSubtract/2;
        }
        N = N-toSubtract;   
    }
    return N % m;
}

    
    
</script>

    </body>
</html>
